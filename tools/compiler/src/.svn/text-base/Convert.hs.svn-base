
module Convert(convert)
    where

import Exptype
import Compiler(Code(..))
import SVM
import CSrc
    
import Monad
import qualified Control.Monad.State as St

-- 编译期环境用于确定变量值的存储位置
data CompileTimeEnvt = NullEnvt |
                       EnvtFrame CompileTimeEnvt [Sym]
                       deriving(Eq, Show)

getBindings (EnvtFrame _ ss) = ss
getBindings NullEnvt = []

extendEnvt = EnvtFrame

-- 在整个作用域上查找变量
lookupvar var envt =
    lookupvar' 0 var envt
    where
      lookupvar' _ _ NullEnvt = error $ "Unbound variable: " ++ (show var)
      lookupvar' level var envt@(EnvtFrame enclosing binds) =
          case lookup var (zip binds [0..(length binds)]) of
            Just idx -> (level, idx)
            Nothing -> lookupvar' (level + 1) var enclosing

-- 只在当前环境查找变量
lookupvarAtCurrentEnvt var (EnvtFrame _ binds) =
    case lookup var (zip binds [0..(length binds)]) of
      Just idx -> (0, idx)
      Nothing -> error $ "Unbound variable: " ++ (show var)

createRef level | level == 0 = "g_svm.reg_envt"
                | otherwise = (createRef (level - 1)) ++ "->enclosing"


type SymbolTab = [(Sym, String)]

data CompileTimeData = CData {
                              modName :: String,
                              symbolTab :: SymbolTab,
                              envt :: CompileTimeEnvt,
                              funcLabel :: Int,
                              valueLabel :: Int
                             }
                       deriving(Eq, Show)

putValueLabel l (CData n s e f _) = (CData n s e f l)

putFuncLabel f (CData n s e _ l) = (CData n s e f l)

data CFile = CFile {
                    srcHead :: [String],
                    dataField :: [String],
                    functions :: [[String]],
                    initCode :: [String],
                    runCode :: [String]
                   }
             deriving(Eq, Show)

comment = "/* This file is generated by scm2c */"
commentHead = "/* File head */"
commentConst = "/* Declaration of consts */"
commentDefs = "/* Definition of functions */"
commentInit = "/* Initialization */"
cfileHead = [
            comment,
            "",
            commentHead,
            "",
            "#include <svm.h>",
            "#include <scheme.h>",
            "#include <gc.h>",
            "#include <builtin.h>",
            "#include <config.h>",
            "",
            "#include <debug.h>",
            "",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            ""
           ]

mainFunc entry = [
                  "int main(int argc, char *argv[])",
                  "{",
                  "scheme_init_all(STACK_SIZE);",
                  "",
                  entry ++ "();",
                  "printf(\"Finish\\n\");",
                  "",
                  "return 0;",
                  "}"
                 ]

emptyFile = CFile [] [] [] [] []
initSrcFile = CFile cfileHead [] [] [] []

buildCFile :: CFile -> [String]
buildCFile file = concatMap (\f -> (f file) ++ [""]) [srcHead, dataField, functions', initCode, runCode]
    where functions' = concat . functions

putHead :: [String] -> CFile -> CFile
putHead head (CFile _ df funcs init run) = CFile {
                                                  srcHead = head,
                                                  dataField = df,
                                                  functions = funcs,
                                                  initCode = init,
                                                  runCode = run
                                                 }

putDataField :: [String] -> CFile -> CFile
putDataField df (CFile head _ funcs init run) = CFile {
                                                       srcHead = head,
                                                       dataField = df,
                                                       functions = funcs,
                                                       initCode = init,
                                                       runCode = run
                                                      }

putFunctions :: [[String]] -> CFile -> CFile
putFunctions funcs (CFile head df _ init run) = CFile {
                                                       srcHead = head,
                                                       dataField = df,
                                                       functions = funcs,
                                                       initCode = init,
                                                       runCode = run
                                                      }
putInitCode :: [String] -> CFile -> CFile
putInitCode init (CFile head df funcs _ run) = CFile {
                                                  srcHead = head,
                                                  dataField = df,
                                                  functions = funcs,
                                                  initCode = init,
                                                  runCode = run
                                                     }

putRunCode :: [String] -> CFile -> CFile
putRunCode run (CFile head df funcs init _) = CFile {
                                                  srcHead = head,
                                                  dataField = df,
                                                  functions = funcs,
                                                  initCode = init,
                                                  runCode = run
                                                    }

type CompileTimeState = (CompileTimeData, CFile)

getCTD :: St.State CompileTimeState CompileTimeData
getCTD = do
  st <- St.get
  return $ fst st

putCTD :: CompileTimeData -> St.State CompileTimeState ()
putCTD d = do
  (_, cf) <- St.get
  St.put $ (d, cf)

getEnvt :: St.State CompileTimeState CompileTimeEnvt
getEnvt = do
  st <- getCTD
  return $ envt st

putEnvt :: CompileTimeEnvt -> St.State CompileTimeState ()
putEnvt env = do
  (CData n s e f v) <- getCTD
  putCTD $ (CData n s env f v)
  

putSymbolTab :: SymbolTab -> St.State CompileTimeState ()
putSymbolTab symtab = do
  (CData n _ e f v) <- getCTD
  putCTD (CData n symtab e f v)
  

getCFile :: St.State CompileTimeState CFile
getCFile = do
  st <- St.get
  return $ snd st

putCFile :: CFile -> St.State CompileTimeState ()
putCFile f = do
  (ctd, _) <- St.get
  St.put $ (ctd, f)

getDataLabel dtype name =
    do
      ctd <- getCTD
      putCTD $ putValueLabel (((+1) . valueLabel) ctd) ctd
      return $ "_" ++ dtype ++ "_scm_" ++ name ++ ((show . valueLabel) ctd)

getFuncLabel name =
    do
      ctd <- getCTD
      putCTD $ putFuncLabel (1 + (funcLabel ctd)) ctd
      return $ "_Func_scm_" ++ name ++ "_" ++ ((show . funcLabel) ctd)

addToHead :: [String] -> St.State CompileTimeState ()
addToHead l = do
  cf <- getCFile
  putCFile $ putHead ((srcHead cf) ++ l) cf


addToDataField :: [String] -> St.State CompileTimeState ()
addToDataField l = do
  cf <- getCFile
  putCFile $ putDataField ((dataField cf) ++ l) cf

addFunction name code = do
  label <- getFuncLabel name
  cf <- getCFile
  putCFile $ putFunctions ((functions cf) ++ [[fdecl label, "{"] ++ (body label) ++ ["}"]]) cf
  return label
    where
      fdecl fn = "static void " ++ "_c" ++ fn ++ "()"
      body fn = (funCallE "BEGIN_PROC" [fn]): code

addConstData protype name fields = do
  label <- getDataLabel protype name
  addToHead [funCallE "SCHEME_DECL" [protype, label]]
  addToDataField [funCallE "SCHEME_DEF_CONST" ([protype, label] ++ fields)]
  return $ label
    where
      data_fields = concatMap (\x -> "," ++ x ) fields
  
createConsts :: Datum -> St.State (CompileTimeData, CFile) String
-- process #t & #f
createConsts Void = return $ "scheme_void"
createConsts (Boolean v) = if v
                           then return "scheme_true"
                           else return "scheme_false"

-- only support 31-bit integer
createConsts (Number v) = return $ funCall "SCHEME_INT_TO_OBJ" [show v]

-- #\char
createConsts (Character v) = return $ "scheme_ascii[" ++ (show v) ++ "]"

-- For string in scheme, we can safely put it's value in code segment.
-- And copy to a new space when we first modify its contents.
createConsts (String s) = do
  label <- getDataLabel "c_string" ""
  addToDataField [(declstr label) ++ ";"]
  cvar <- addConstData "String" ""
          [label, show $ length s]
  return  cvar
    where
      declstr name = "static char " ++ name ++ "[] = " ++ (show s)

createConsts (Symbol Nil) = error $ "Unexcepted inputed data."
createConsts (Symbol sym@(Sym s)) = do
  d <- getCTD
  case ((lookup sym) . symbolTab) d of
    Just label -> return label
    Nothing -> do
      label <- getDataLabel "c_string" ""
      addToDataField [declstr label]
      cvar <- addConstData "Symbol" ""
              [label, show $ length s]
      putSymbolTab ((sym, cvar):(symbolTab d))
      return cvar
    where
      declstr name = "static char " ++ name ++ "[] = " ++ (show s) ++ ";"

createConsts (SExp (car : []) cdr) = do
  car_var <- createConsts car
  cdr_var <- createConsts cdr
  addConstData "Pair" "" [typeCast "Obj" car_var, typeCast "Obj" cdr_var]

createConsts (List []) = return $ "scheme_null"
createConsts lst = createConsts (listToSExp lst)

instr2c :: Instr -> St.State CompileTimeState [String]
instr2c (FetchConst datum) = do
  value <- createConsts datum
  return $ ["svm_register(value) = " ++ (typeCast "Obj" value) ++ ";"]

instr2c BlankLn = return [""]

instr2c Nop = return [""]

instr2c Push = return $ [funCallE "svm_push" []]

instr2c (Label label) = return $ [funCallE "LABEL" [label]]

instr2c LeaveProc = return $ [funCallE "LEAVE_PROC" []]

instr2c Apply = return $ [funCallE "apply_procedure" []]

instr2c (CallBuiltin (Sym fun) argc) = return $ [funCallBuiltin fun argc]

instr2c (PushCont label) = return $ [funCallE "push_continuation" [label]]

instr2c (Goto label) = return $ [funCallE "GOTO" [label]]

instr2c (MoveSp off) = return $ [funCallE "MOVESP" [show off]]

instr2c (AccStack off) = return $ [funCallE "ACCESS_STACK" [show off]]

instr2c (IfTrue con alt) = do
  con_code <- convSequence con'
  alt_code <- convSequence alt'
  return $ ifExpr
             (funCall "SCHEME_TRUEP" [funCall "svm_register" ["value"]])
             con_code
             alt_code
    where
      con' = map makeInstr con
      alt' = map makeInstr alt

instr2c (IfFalse con alt) = do
  con_code <- convSequence con'
  alt_code <- convSequence alt'
  return $ ifExpr
             (funCall "SCHEME_FALSEP" [funCall "svm_register" ["value"]])
             con_code
             alt_code
    where
      con' = map makeInstr con
      alt' = map makeInstr alt

-- instr2c (MultCond 

instr2c (LookupVar var) =
    do
      env <- getEnvt
      return [createCode $ lookupvar var env]
    where
      createCode (level, offset) =
          funCallE "LOOKUP_VAR" [createRef level, show offset]

instr2c (NewBind var) =
    do
      env <- getEnvt
      return [createCode $ lookupvarAtCurrentEnvt var env]
    where
      createCode (level, offset) =
          funCallE "BIND_VAR" [createRef level, show offset]

instr2c (ReBind var) =
    do
      env <- getEnvt
      return [createCode $ lookupvarAtCurrentEnvt var env]
    where
      createCode (level, offset) =
          funCallE "BIND_VAR" [createRef level, show offset]

instr2c (MakeClosure (Sym name) (Args args) body) =
    do
      -- create new environment for compile functions body
      env <- getEnvt
      putEnvt $ extendEnvt env (args ++ (scanForNewbind body'))
      code <- convSequence body'
      fn <- addFunction name code
      tl <- getDataLabel name ""
      addToHead ["static void " ++ fn ++ "();"]
      addToDataField [template tl fn]
      cl <- addConstData "Closure" (name ++ "_") ["global_environment", tl]
      -- restore environment
      putEnvt env
      return $ [(funCall "SCHEME_CLOSURE_ENVT" [cl]) ++ " = g_svm.reg_envt;",
                "svm_register(value) = (Scheme_Obj_t *)" ++ cl ++ ";", ""]
      where
        body' = map makeInstr body
        template name fn = "static " ++
                           (funCallE "SCHEME_DEF_TEMPLATE" [name, fn])

instr2c instr = error $ "Unsupported instrument: " ++ (show instr)


convSequence :: [SvmInstr] -> St.State CompileTimeState [String]
convSequence instrs = ((liftM (foldl (++) [])) . (mapM (instr2c . getInstr))) instrs

scanForNewbind = concatMap (p . getInstr)
    where p (NewBind x) = [x]
          p _ = []

convert :: String -> [SvmInstr] -> [String]
convert name instrs =
    (St.evalState (code2c instrs) initState) ++ [""] ++ (mainFunc entry)
    where
      symbols = scanForNewbind instrs
      entry = name ++ "_mod_run"
      createRunCode name body =
          ["static void " ++ entry ++ "()", "{", "push_continuation(scheme_return);", ""]
          ++ body ++ ["LABEL(scheme_return);", "}"]
      cInitCode =
          ["void mod_init()", "{",
           (funCall "SCHEME_ENVT_BINDINGS" ["global_environment"]) ++
           " = " ++ (funCallE "alloc_binds" [(show . length) symbols]),
           "}"]
      code2c code = do
        runc <- convSequence instrs
        cfile <- getCFile
        putCFile $ putInitCode cInitCode ((putRunCode $ createRunCode name runc) cfile)
        file <- getCFile
        return $ buildCFile file
      initState = ((CData name [] (EnvtFrame NullEnvt symbols) 0 0), initSrcFile)
